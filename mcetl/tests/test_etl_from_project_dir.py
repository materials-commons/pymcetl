import unittest
# import pytest
import os
from random import randint
from materials_commons.api import create_project, get_all_projects
from backend.servers.etlserver.internal_etl.BuildProjectExperimentWithETL import BuildProjectExperiment
from backend.servers.etlserver.common.worksheet_data import ExcelIO
from backend.servers.etlserver.database.DatabaseInterface import DatabaseInterface
from backend.servers.etlserver.common.McdirHelper import McdirHelper

EXCEL_FILE_NAME = "small_input.xlsx"
DATA_DIR_NAME = "data"
TEST_DIR = "ProjectDir/ForETL"
TEST_PROJECT_NAME = "Test1"
USER_TEST_PROJECT = False


def fake_name(prefix):
    number = "%05d" % randint(0, 99999)
    return prefix + number


class TestFileProcessSample(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.apikey = os.environ['MC_API_KEY']
        print("MC_API_KEY = {}".format(cls.apikey))
        cls.project = None

        if USER_TEST_PROJECT:
            all_projects = get_all_projects()
            for project in all_projects:
                if project.name == TEST_PROJECT_NAME:
                    cls.project = project
                    cls.project_name = project.name
                    cls.project_id = project.id
                    break
        else:
            cls.project_name = fake_name("TestForETL-")
            description = "Test project generated by automated test"
            cls.project = create_project(cls.project_name, description)
            cls.project_id = cls.project.id

        cls.data_dir_path = os.path.abspath(os.environ['TEST_DATA_DIR'])
        print("TEST_DATA_DIR = {}".format(cls.data_dir_path))

        project = cls.project

        project.local_path = cls.data_dir_path
        local_dir_path = os.path.join(cls.data_dir_path, TEST_DIR)
        project.add_directory_tree_by_local_path(local_dir_path)
        print("project {} ({})".format(project.name, project.id))
        print("project.local_path = {}".format(project.local_path))
        print("local_dir_path = {}".format(local_dir_path))

    def test_is_setup_correctly(self):
        self.assertIn('MC_API_KEY', os.environ)
        self.assertIn('TEST_DATA_DIR', os.environ)
        self.assertIn('MCDIR', os.environ)
        self.assertIsNotNone(self.apikey, "Missing test api key; MC_API_KEY not set properly")

        self.assertIsNotNone(self.project)
        self.assertIsNotNone(self.project.name)
        self.assertEqual(self.project_name, self.project.name)
        self.assertIsNotNone(self.project.id)
        self.assertEqual(self.project_id, self.project.id)

        directory = self.project.get_top_directory()
        for dir_name in TEST_DIR.split('/'):
            for file_or_dir in directory.get_children():
                if file_or_dir.name == dir_name:
                    directory = file_or_dir
        self.assertIsNotNone(directory, "Missing directory for test data, {}".format(TEST_DIR))

        found_excel_file = False
        found_data_dir = False
        for file_or_dir in directory.get_children():
            if file_or_dir.name == EXCEL_FILE_NAME:
                found_excel_file = True
            if file_or_dir.name == DATA_DIR_NAME:
                found_data_dir = True
        self.assertTrue(found_excel_file, "Missing Excel File, {}, in test data".format(EXCEL_FILE_NAME))
        self.assertTrue(found_data_dir, "Missing Data Dir, {}, in test data".format(DATA_DIR_NAME))

    # @pytest.mark.skip()
    def test_server_side_file_for_internal_path(self):
        self.assertIsNotNone(self.project)
        self.assertIn('MCDIR', os.environ)

        builder = BuildProjectExperiment(self.apikey)

        spread_sheet_path = os.path.join(TEST_DIR, EXCEL_FILE_NAME)
        top_directory = self.project.get_top_directory()
        file = builder._find_file_in_dir(top_directory, spread_sheet_path.split('/'))
        self.assertIsNotNone(file, "Could not find file, '{}' in project directories".format(spread_sheet_path))

        internal_file_path = builder._server_side_file_path_for_project_path(self.project, spread_sheet_path)
        self.assertIsNotNone(internal_file_path, "Could not find internal file path for file, '{}'"
                             .format(spread_sheet_path))

    # @pytest.mark.skip()
    def test_builder_gets_spreadsheet_data(self):
        self.assertIsNotNone(self.project)
        builder = BuildProjectExperiment(self.apikey)
        spread_sheet_path = os.path.join(TEST_DIR, EXCEL_FILE_NAME)
        builder._set_etl_source_date_from_path(self.project, spread_sheet_path)
        self.assertEqual(builder.etl_source_data[1][1], "SAMPLES")

    # @pytest.mark.skpi()
    def test_build_experiment_from_etl(self):
        self.assertIsNotNone(self.project)
        self.assertIn('MCDIR', os.environ)

        print("\nProject name = {}".format(self.project.name))

        builder = BuildProjectExperiment(self.apikey)
        spreadsheet_path = os.path.join(TEST_DIR, EXCEL_FILE_NAME)
        data_dir_path = os.path.join(TEST_DIR, DATA_DIR_NAME)
        experiment_name = "Test of internal ETL"
        builder.build(spreadsheet_path, data_dir_path, self.project.id, experiment_name)

    # @pytest.mark.skip()
    def test_open_excel_raw(self):
        self.assertIsNotNone(self.project)
        spread_sheet_path = os.path.join(TEST_DIR, EXCEL_FILE_NAME)
        top_directory = self.project.get_top_directory()
        file = self._find_file_in_dir(top_directory, spread_sheet_path.split('/'))
        self.assertIsNotNone(file)
        self.assertEqual(file.name, EXCEL_FILE_NAME)

        mc_dirs_base = os.environ['MCDIR']
        internal_file_path = None
        if mc_dirs_base:
            mc_dirs = mc_dirs_base.split(":")
            for mc_dir in mc_dirs:
                if os.path.exists(mc_dir):
                    probe = self._internal_file_path_from_file_record(file)
                    probe = os.path.join(mc_dir, probe)
                    if os.path.exists(probe):
                        internal_file_path = probe
                        break
        self.assertIsNotNone(internal_file_path)

        # SET UP THE LINK
        uuid = DatabaseInterface().get_uuid()
        link_base_path = McdirHelper().get_excel_file_link_dir()
        file_name = "{}.xlsx".format(uuid)
        link_path = os.path.join(link_base_path, file_name)
        os.link(internal_file_path, link_path)

        # READ DATA
        sheet_name_list = None
        source_data = None
        excel_io_controller = ExcelIO()
        excel_io_controller.read_workbook(link_path)
        sheet_name_list = excel_io_controller.sheet_name_list()
        excel_io_controller.set_current_worksheet_by_index(0)
        source_data = excel_io_controller.read_entire_data_from_current_sheet()
        excel_io_controller.close()

        # TAKE DOWN LINK
        os.unlink(link_path)

        sheet_name = sheet_name_list[0]
        self.assertEqual(sheet_name, 'Sheet')
        self.assertEqual(source_data[0][0], 'PROJ: Generic Testing')

    # @pytest.mark.skip()
    def test_open_excel_in_builder(self):
        self.assertIsNotNone(self.project)
        builder = BuildProjectExperiment(self.apikey)
        spread_sheet_path = os.path.join(TEST_DIR, EXCEL_FILE_NAME)
        builder._set_etl_source_date_from_path(self.project, spread_sheet_path)
        self.assertEqual(builder.etl_source_data[0][0], 'PROJ: Generic Testing')

    @staticmethod
    def _internal_file_path_from_file_record(file):
        file_id = file.id
        if file.usesid:
            file_id = file.usesid
        file_path = "{}/{}/{}".format(file_id[9:11], file_id[11:13], file_id)
        return file_path

    def _find_file_in_dir(self, directory, path_list):
        if not path_list:
            return None
        name = path_list[0]
        for file_or_dir in directory.get_children():
            if file_or_dir.name == name:
                path_list = path_list[1:]
                if len(path_list) > 0 and file_or_dir.otype == 'directory':
                    return self._find_file_in_dir(file_or_dir, path_list)
                elif len(path_list) == 0:
                    return file_or_dir
        return None
